// Generated by CoffeeScript 1.4.0
(function() {
  var addBody, addPickup, addTile, anim_frame, anim_subframe, apples, bodies, body_list, bridges, bump, can_move, canvas, canvas_height, canvas_width, check_movement, check_pickup, clockwise, clockwise_table, copy, ctx, draw_debug, draw_entities, draw_scenery, elem, frame, getImage, imageURL, images, is_occupied, keys, keys_down, letters, makeGrid, makeImage, move_gazelle, move_player, move_rhino, num_columns, num_rows, occupying, pickup_list, pickups, scenery, square_height, square_width, start_moving, status, try_align, update_entities, walkable_bg, word;

  canvas = null;

  ctx = null;

  frame = 0;

  anim_frame = 0;

  anim_subframe = 0;

  canvas_width = 640;

  canvas_height = 480;

  num_rows = 24;

  num_columns = 30;

  square_width = 16;

  square_height = 16;

  makeGrid = function() {
    var i, j, row, rows, _i, _j;
    rows = [];
    for (i = _i = 1; 1 <= num_rows ? _i <= num_rows : _i >= num_rows; i = 1 <= num_rows ? ++_i : --_i) {
      row = [];
      for (j = _j = 1; 1 <= num_columns ? _j <= num_columns : _j >= num_columns; j = 1 <= num_columns ? ++_j : --_j) {
        row.push(null);
      }
      rows.push(row);
    }
    return rows;
  };

  scenery = makeGrid();

  bodies = makeGrid();

  pickups = makeGrid();

  body_list = [];

  pickup_list = [];

  word = 'FIRST';

  letters = '';

  apples = 0;

  bridges = 0;

  addPickup = function(sprite, r, c, misc) {
    var k, obj, v, _i, _len, _ref, _ref1;
    if (misc == null) {
      misc = {};
    }
    obj = {
      sprite: sprite,
      x: c * square_width,
      y: r * square_height,
      r: r,
      c: c,
      width: 2,
      height: 2,
      toString: function() {
        return "[pickup " + this.sprite + " x:" + this.x + " y:" + this.y + " r:" + this.r + " c:" + this.c + "]";
      }
    };
    for (k in misc) {
      v = misc[k];
      obj[k] = v;
    }
    _ref = occupying(obj);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], r = _ref1[0], c = _ref1[1];
      pickups[r][c] = obj;
    }
    pickup_list.push(obj);
    return null;
  };

  addTile = function(letter, r, c) {
    addPickup('tile', r, c, {
      letter: letter
    });
    return null;
  };

  addBody = function(sprite, r, c, misc) {
    var k, obj, v, _i, _len, _ref, _ref1;
    if (misc == null) {
      misc = {};
    }
    obj = {
      sprite: sprite,
      x: c * square_width,
      y: r * square_height,
      r: r,
      c: c,
      width: 2,
      height: 2,
      facing: 'down',
      state: 'stopped',
      speed: 2,
      was_moving: false,
      toString: function() {
        return "[body " + this.sprite + " x:" + this.x + " y:" + this.y + " r:" + this.r + " c:" + this.c + "]";
      }
    };
    for (k in misc) {
      v = misc[k];
      obj[k] = v;
    }
    _ref = occupying(obj);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], r = _ref1[0], c = _ref1[1];
      bodies[r][c] = obj;
    }
    body_list.push(obj);
    return null;
  };

  makeImage = function(src) {
    var img;
    img = new Image();
    img.src = src;
    return img;
  };

  images = {};

  imageURL = function(entity) {
    switch (entity.sprite) {
      case 'tile':
        return "img/floor/tile/" + entity.letter + ".png";
      case 'apple':
        return 'img/floor/apple.png';
      case 'bridge':
        return 'img/floor/bridge.png';
      case 'dartdemon':
        return "img/dartdemon/" + entity.facing + ".png";
      default:
        switch ((entity.was_moving ? 'moving' : entity.state)) {
          case 'stopped':
            return "img/" + entity.sprite + "/stopped/" + entity.facing + ".png";
          case 'moving':
            return "img/" + entity.sprite + "/moving/" + entity.facing + "/" + anim_frame + ".png";
        }
    }
  };

  getImage = function(entity) {
    var img, url;
    url = imageURL(entity);
    if (img = images[url]) {
      return img;
    } else {
      img = makeImage(url);
      images[url] = img;
      return img;
    }
  };

  keys_down = {};

  status = 'playing';

  draw_scenery = function() {
    var c, r, _i, _j, _ref, _ref1;
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas_width, canvas_height);
    for (r = _i = 0, _ref = num_rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; r = 0 <= _ref ? ++_i : --_i) {
      for (c = _j = 0, _ref1 = num_columns - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
        ctx.fillStyle = (function() {
          switch (scenery[r][c]) {
            case 'bare':
              return '#ffffcc';
            case 'grass':
              return '#00ff00';
            case 'water':
              return '#0033ff';
            case 'tree':
              return '#006600';
          }
        })();
        ctx.fillRect(c * square_width + 10, r * square_height + 10, square_width, square_height);
      }
    }
    return null;
  };

  draw_debug = function() {
    var status_text;
    ctx.fillStyle = 'white';
    ctx.fillText("" + (Math.floor(frame / 60)) + " | " + (frame % 60), 10, 410);
    ctx.fillText("Letters: " + letters, 10, 425);
    ctx.fillText("" + apples + " apples, " + bridges + " bridges", 10, 440);
    ctx.fillText("Target word: " + word, 10, 455);
    status_text = status === 'dead' ? 'Dead...' : letters === word ? 'Victory!' : word.indexOf(letters) === 0 ? 'Playing' : 'Failure...';
    ctx.fillText(status_text, 10, 470);
    return null;
  };

  draw_entities = function() {
    var entity, _i, _j, _len, _len1;
    for (_i = 0, _len = pickup_list.length; _i < _len; _i++) {
      entity = pickup_list[_i];
      ctx.drawImage(getImage(entity), entity.x + 10, entity.y + 10);
    }
    for (_j = 0, _len1 = body_list.length; _j < _len1; _j++) {
      entity = body_list[_j];
      ctx.drawImage(getImage(entity), entity.x + 10, entity.y + 10);
    }
    return null;
  };

  walkable_bg = function(r, c) {
    var scene;
    scene = scenery[r][c];
    return scene === 'bare' || scene === 'grass';
  };

  is_occupied = function(r, c, entity_to_move) {
    var _ref;
    if ((_ref = bodies[r][c]) !== null && _ref !== entity_to_move) {
      return true;
    }
    if ((entity_to_move.sprite !== 'player') && pickups[r][c]) {
      return true;
    }
    return !walkable_bg(r, c);
  };

  bump = function(entity) {
    switch (entity.facing) {
      case 'left':
        entity.x -= entity.speed;
        break;
      case 'right':
        entity.x += entity.speed;
        break;
      case 'up':
        entity.y -= entity.speed;
        break;
      case 'down':
        entity.y += entity.speed;
    }
    return null;
  };

  start_moving = function(entity, dir) {
    var c, r, _i, _len, _ref, _ref1;
    entity.facing = dir;
    entity.state = 'moving';
    bump(entity);
    _ref = occupying(entity);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], r = _ref1[0], c = _ref1[1];
      bodies[r][c] = entity;
    }
    return null;
  };

  check_pickup = function(r, c) {
    var p, pickup, _i, _len, _ref, _ref1;
    if (pickup = pickups[r][c]) {
      if (!(pickup.r === r && pickup.c === c)) {
        return;
      }
      _ref = occupying(pickup);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], r = _ref1[0], c = _ref1[1];
        pickups[r][c] = null;
      }
      pickup_list = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = pickup_list.length; _j < _len1; _j++) {
          p = pickup_list[_j];
          if (p !== pickup) {
            _results.push(p);
          }
        }
        return _results;
      })();
      switch (pickup.sprite) {
        case 'tile':
          letters += pickup.letter;
          if (letters === word) {
            status = 'complete';
          }
          break;
        case 'apple':
          apples++;
          break;
        case 'bridge':
          bridges++;
      }
    }
    return null;
  };

  clockwise_table = {
    up: 'right',
    right: 'down',
    down: 'left',
    left: 'up'
  };

  clockwise = function(dir) {
    return clockwise_table[dir];
  };

  occupying = function(entity) {
    var bottom, bottom_row, c, left, left_column, r, right, right_column, squares, top, top_row, _i, _j;
    top = entity.y;
    bottom = top + entity.height * square_height;
    left = entity.x;
    right = left + entity.width * square_width;
    top_row = Math.floor(top / square_height);
    bottom_row = Math.ceil(bottom / square_height) - 1;
    left_column = Math.floor(left / square_width);
    right_column = Math.ceil(right / square_width) - 1;
    squares = [];
    for (r = _i = top_row; top_row <= bottom_row ? _i <= bottom_row : _i >= bottom_row; r = top_row <= bottom_row ? ++_i : --_i) {
      for (c = _j = left_column; left_column <= right_column ? _j <= right_column : _j >= right_column; c = left_column <= right_column ? ++_j : --_j) {
        squares.push([r, c]);
      }
    }
    return squares;
  };

  copy = function(entity) {
    return {
      speed: entity.speed,
      x: entity.x,
      y: entity.y,
      height: entity.height,
      width: entity.width
    };
  };

  can_move = function(entity, dir) {
    var c, entity_copy, r, _i, _len, _ref, _ref1;
    entity_copy = copy(entity);
    entity_copy.facing = dir;
    bump(entity_copy);
    _ref = occupying(entity_copy);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], r = _ref1[0], c = _ref1[1];
      if (is_occupied(r, c, entity)) {
        return false;
      }
    }
    return true;
  };

  move_player = function(entity) {
    var cw0, cw1, cw2, cw3, dir, no_keys, _i, _len, _ref;
    cw0 = entity.facing;
    cw1 = clockwise(cw0);
    cw2 = clockwise(cw1);
    cw3 = clockwise(cw2);
    no_keys = true;
    _ref = [cw0, cw1, cw2, cw3];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dir = _ref[_i];
      if (keys_down[dir]) {
        no_keys = false;
        entity.facing = dir;
        if (can_move(entity, dir)) {
          start_moving(entity, dir);
          return;
        }
      }
    }
    if (no_keys || keys_down[cw0]) {
      entity.facing = cw0;
    }
    return null;
  };

  move_gazelle = function(entity) {
    var cw0, cw1, cw2, cw3, dir, walled_now, walls, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    cw0 = entity.facing;
    cw1 = clockwise(cw0);
    cw2 = clockwise(cw1);
    cw3 = clockwise(cw2);
    walls = {};
    walled_now = false;
    _ref = ['up', 'down', 'left', 'right'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dir = _ref[_i];
      if (!can_move(entity, dir)) {
        walls[dir] = walled_now = true;
      }
    }
    if (entity.walled) {
      _ref1 = [cw1, cw0, cw3, cw2];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        dir = _ref1[_j];
        if (!walls[dir]) {
          start_moving(entity, dir);
          break;
        }
      }
    } else {
      _ref2 = [cw0, cw3, cw2, cw1];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        dir = _ref2[_k];
        if (!walls[dir]) {
          start_moving(entity, dir);
          break;
        }
      }
    }
    entity.walled = walled_now;
    return null;
  };

  move_rhino = function(entity) {
    var dir, opp;
    dir = entity.facing;
    opp = clockwise(clockwise(dir));
    if (can_move(entity, dir)) {
      start_moving(entity, dir);
    } else if (can_move(entity, opp)) {
      start_moving(entity, opp);
    }
    return null;
  };

  try_align = function(entity) {
    if (entity.x % square_width === 0 && entity.y % square_height === 0) {
      entity.c = Math.floor(entity.x / square_width);
      entity.r = Math.floor(entity.y / square_height);
      return true;
    }
    return false;
  };

  check_movement = function(entity) {
    var c, r, was_occupying, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    switch (entity.state) {
      case 'moving':
        entity.was_moving = true;
        was_occupying = occupying(entity);
        bump(entity);
        if (try_align(entity)) {
          entity.state = 'stopped';
          for (_i = 0, _len = was_occupying.length; _i < _len; _i++) {
            _ref = was_occupying[_i], r = _ref[0], c = _ref[1];
            bodies[r][c] = null;
          }
          _ref1 = occupying(entity);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            _ref2 = _ref1[_j], r = _ref2[0], c = _ref2[1];
            bodies[r][c] = entity;
          }
          if (entity.sprite === 'player') {
            check_pickup(entity.r, entity.c);
          }
        }
        break;
      case 'stopped':
        entity.was_moving = false;
        switch (entity.sprite) {
          case 'player':
            move_player(entity);
            break;
          case 'gazelle':
            move_gazelle(entity);
            break;
          case 'rhino':
            move_rhino(entity);
        }
    }
    return null;
  };

  update_entities = function() {
    var entity, _i, _len;
    for (_i = 0, _len = body_list.length; _i < _len; _i++) {
      entity = body_list[_i];
      check_movement(entity);
    }
    return null;
  };

  elem = function(x, ys) {
    var y, _i, _len;
    for (_i = 0, _len = ys.length; _i < _len; _i++) {
      y = ys[_i];
      if (x === y) {
        return true;
      }
    }
    return false;
  };

  keys = {
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    87: 'up',
    65: 'left',
    83: 'down',
    68: 'right'
  };

  $(document).ready(function() {
    var animloop, c, c2, level, level_table, r, r2, row, str, val, _i, _j, _len, _len1;
    canvas = $('#canvas')[0];
    ctx = canvas.getContext('2d');
    $(document).keydown(function(evt) {
      var key;
      if (key = keys[evt.which]) {
        keys_down[key] = true;
      }
      return null;
    });
    $(document).keyup(function(evt) {
      var key;
      if (key = keys[evt.which]) {
        delete keys_down[key];
      }
      return null;
    });
    window.requestAnimFrame = (function() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        return window.setTimeout(callback, 1000 / 60);
      };
    })();
    level_table = {
      0: 'bare',
      1: 'grass',
      2: 'water',
      3: 'tree'
    };
    level = [[3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 3, 3, 3], [3, 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 3, 3], [3, 3, 3, 3, 2, 2, 0, 0, 0, 0, 0, 3, 3, 3, 3], [3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3], [3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 2, 2, 0, 0, 3, 3, 3, 0, 3, 3], [3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3], [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3], [3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]];
    for (r = _i = 0, _len = level.length; _i < _len; r = ++_i) {
      row = level[r];
      for (c = _j = 0, _len1 = row.length; _j < _len1; c = ++_j) {
        val = row[c];
        r2 = r * 2;
        c2 = c * 2;
        str = level_table[val];
        scenery[r2][c2] = scenery[r2][c2 + 1] = scenery[r2 + 1][c2] = scenery[r2 + 1][c2 + 1] = level_table[val];
      }
    }
    addTile('F', 6, 12);
    addTile('I', 4, 16);
    addTile('R', 4, 24);
    addTile('S', 12, 26);
    addTile('T', 16, 24);
    addPickup('apple', 10, 16);
    addBody('player', 10, 14);
    addBody('gazelle', 12, 14, {
      speed: 4,
      walled: false
    });
    return (animloop = function() {
      requestAnimFrame(animloop);
      if ($('#running')[0].checked) {
        frame++;
        anim_subframe++;
        if (anim_subframe === 5) {
          anim_subframe = 0;
          anim_frame = (anim_frame + 1) % 4;
        }
        draw_scenery();
        draw_debug();
        draw_entities();
        update_entities();
        $('#debug')[0].innerHTML = "" + body_list + "<br />" + pickup_list;
      }
      return null;
    })();
  });

}).call(this);
