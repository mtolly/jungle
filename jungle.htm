<html>

<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
</head>

<body>
<canvas id="canvas" width="640" height="480"></canvas>
<script type="text/javascript">

var frame         = 0;
var anim_frame    = 0; // 0 -> 1 -> 2 -> 3 -> 0, every 5th frame
var anim_subframe = 0; // 0 -> 1 -> 2 -> 3 -> 4 -> 0, every frame
var canvas_width  = 640;
var canvas_height = 480;

var num_rows      = 12;
var num_columns   = 15;
var square_width  = 32;
var square_height = 32;

// The unchanging background of the world.
// 0: bare
// 1: grass
// 2: water
// 3: tree
var scenery =
  [ [ 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3 ]
  , [ 3, 3, 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 3, 3, 3 ]
  , [ 3, 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 3, 3 ]
  , [ 3, 3, 3, 3, 2, 2, 0, 0, 0, 0, 0, 3, 3, 3, 3 ]
  , [ 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3 ]
  , [ 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3 ]
  , [ 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3 ]
  , [ 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3 ]
  , [ 3, 3, 3, 3, 3, 2, 2, 0, 0, 3, 3, 3, 0, 3, 3 ]
  , [ 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3 ]
  , [ 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3 ]
  , [ 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3 ]
  ];

var word = 'FIRST';
var letters = '';
var apples = 0;
var bridges = 0;

function newTile(letter, r, c) {
  return { sprite: 'tile'
         , x:      c * square_width
         , y:      r * square_height
         , letter: letter
         };
}

function newBody(sprite, r, c) {
  return { sprite: sprite
         , x:      c * square_width
         , y:      r * square_height
         , facing: 'down'
         , state:  'stopped'
         };
}

// Entities are square-sized objects which can change state.
var floor_entities =
  [ newTile('F', 3, 6)
  , newTile('I', 2, 8)
  , newTile('R', 2, 12)
  , newTile('S', 6, 13)
  , newTile('T', 8, 12)
  ];
var body_entities =
  [ newBody('player', 5, 7)
  ];

function makeImage(src) {
  var img = new Image();
  img.src = src;
  return img;
}

images = {};

function imageURL(entity) {
  switch (entity.sprite) {
    case 'tile':
      return 'img/tile/' + entity.letter + '.png';
    case 'player':
      switch (entity.state) {
        case 'stopped':
          return 'img/player/stopped/' + entity.facing + '.png';
        case 'moving':
          return 'img/player/moving/' + entity.facing + '/' + anim_frame + '.png';
      }
    case 'dartdemon':
      return 'img/dartdemon/' + entity.facing + '.png';
  }
}

function getImage(entity) {
  var url = imageURL(entity);
  if (typeof images[url] == 'undefined') {
    var img = makeImage(url);
    images[url] = img;
    return img;
  }
  return images[url];
}

var keys_down = {};

// entities which will be added/deleted on end of frame
var floor_to_add    = [];
var floor_to_delete = [];
var body_to_add     = [];
var body_to_delete  = [];

// 'playing', 'dead', 'complete'
var status = 'playing';

$(document).ready(function(){

  var canvas = $('#canvas')[0];
  var ctx = canvas.getContext('2d');
  
  function draw_scenery() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas_width, canvas_height);
    
    var r, c;
    for (r = 0; r < num_rows; r++) {
      for (c = 0; c < num_columns; c++) {
        switch (scenery[r][c]) {
          case 0: ctx.fillStyle = '#ffffcc'; break;
          case 1: ctx.fillStyle = '#00ff00'; break;
          case 2: ctx.fillStyle = '#0033ff'; break;
          case 3: ctx.fillStyle = '#006600'; break;
        }
        ctx.fillRect(c * square_width + 10, r * square_height + 10, square_width, square_height);
      }
    }
  }
  
  function draw_debug() {
    ctx.fillStyle = 'white';
    var frameText = Math.floor(frame / 60) + ' | ' + (frame % 60);
    ctx.fillText(frameText, 10, 410);
    ctx.fillText('Letters: ' + letters, 10, 425);
    ctx.fillText('Target word: ' + word, 10, 440);
    if (status == 'dead') {
      ctx.fillText('Dead...', 10, 455);
    }
    else if (letters == word) {
      ctx.fillText('Victory!', 10, 455);
    }
    else if (word.indexOf(letters) === 0) {
      ctx.fillText('Playing', 10, 455);
    }
    else {
      ctx.fillText('Failure...', 10, 455);
    }
  }
  
  function draw_entities() {
    for (var i = 0; i < floor_entities.length; i++) {
      var entity = floor_entities[i];
      ctx.drawImage(getImage(entity), entity.x + 10, entity.y + 10);
    }
    for (var i = 0; i < body_entities.length; i++) {
      var entity = body_entities[i];
      ctx.drawImage(getImage(entity), entity.x + 10, entity.y + 10);
    }
  }
  
  // row and column should be multiples of 0.5.
  function is_occupied(row, column, ignore_entity) {
    for (var i = 0; i < body_entities.length; i++) {
      var entity = body_entities[i];
      if (ignore_entity == entity) continue;
      var x  = entity.x;
      var y  = entity.y;
      var cx = column * square_width;
      var ry = row * square_height;
      if
        (  cx - square_width < x
        && x < cx + square_width
        && ry - square_height < y
        && y < ry + square_height
        ) {
        return true;
      }
    }
    return !walkable_bg(row, column);
  }
  
  // row and column should be multiples of 0.5.
  function walkable_bg(row, column) {
    if (row != Math.floor(row)) {
      return walkable_bg(row - 0.5, column) && walkable_bg(row + 0.5, column);
    }
    if (column != Math.floor(column)) {
      return walkable_bg(row, column - 0.5) && walkable_bg(row, column + 0.5);
    }
    if (scenery[row][column] == 2) return false;
    if (scenery[row][column] == 3) return false;
    return true;
  }
  
  // returns [r, c] or null, where r and c are multiples of 0.5.
  function get_square(entity) {
    var x = entity.x;
    var y = entity.y;
    if (x % (square_width / 2) != 0 || y % (square_height / 2) != 0) {
      return null;
    }
    return [y / square_height, x / square_width];
  }
  
  function get_next_square(entity, direction) {
    var sq = get_square(entity);
    var r = sq[0];
    var c = sq[1];
    switch (direction) {
      case 'left':  return [r, c - 0.5];
      case 'right': return [r, c + 0.5];
      case 'up':    return [r - 0.5, c];
      case 'down':  return [r + 0.5, c];
    }
  }
  
  function bump(entity) {
    switch (entity.facing) {
      case 'left':  entity.x -= 2; break;
      case 'right': entity.x += 2; break;
      case 'up':    entity.y -= 2; break;
      case 'down':  entity.y += 2; break;
    }
  }
  
  function start_moving(entity, direction) {
    entity.facing = direction;
    entity.state = 'moving';
    bump(entity);
  }
  
  function check_pickup(x, y) {
    for (var i = 0; i < floor_entities.length; i++) {
      var entity = floor_entities[i];
      if (entity.x == x && entity.y == y) {
        floor_to_delete.push(entity);
        switch (entity.sprite) {
          case 'tile':
            letters += entity.letter;
            if (letters == word) {
              status = 'complete';
            }
            break;
        }
      }
    }
  }
  
  // Handles updating the moving/stopped state, and applying movement to
  // position.
  function check_movement(entity) {
    if (entity.state == 'moving') {
      bump(entity);
      if (entity.x % (square_width / 2) == 0 && entity.y % (square_height / 2) == 0) {
        entity.state = 'stopped';
        if (entity.sprite == 'player') {
          check_pickup(entity.x, entity.y);
        }
      }
    }
    else if (entity.state == 'stopped') {
      if (entity.sprite == 'player') {
        var kd = Object.keys(keys_down);
        if (kd.length) {
          var dir = kd[0];
          entity.facing = dir;
          if (can_move(entity, dir)) {
            start_moving(entity, dir);
          }
        }
      }
    }
  }
  
  function can_move(entity, direction) {
    var next_sq = get_next_square(entity, direction);
    return !is_occupied(next_sq[0], next_sq[1], entity);
  }
  
  function update_entities() {
    for (var i = 0; i < body_entities.length; i++) {
      check_movement(body_entities[i]);
    }
  }
  
  function delete_entities() {
    var i, j;
    
    var new_floor = [];
    outer:
    for (i = 0; i < floor_entities.length; i++) {
      for (j = 0; j < floor_to_delete.length; j++) {
        if (floor_entities[i] === floor_to_delete[j]) {
          continue outer;
        }
      }
      // don't delete, copy to new version of array
      new_floor.push(floor_entities[i]);
    }
    floor_entities = new_floor;
    
    var new_body = [];
    outer:
    for (i = 0; i < body_entities.length; i++) {
      for (j = 0; j < body_to_delete.length; j++) {
        if (body_entities[i] === body_to_delete[j]) {
          continue outer;
        }
      }
      // don't delete, copy to new version of array
      new_body.push(body_entities[i]);
    }
    body_entities = new_body;
    
    floor_to_delete = [];
    body_to_delete = [];
  }
  
  function add_entities() {
    floor_entities = floor_entities.concat(floor_to_add);
    body_entities = body_entities.concat(body_to_add);
  }
  
  $(document).keydown(function(evt) {
    switch (evt.which) {
      case 37: keys_down['left']  = true; break;
      case 38: keys_down['up']    = true; break;
      case 39: keys_down['right'] = true; break;
      case 40: keys_down['down']  = true; break;
    }
  });
  
  $(document).keyup(function(evt) {
    switch (evt.which) {
      case 37: delete keys_down['left'];  break;
      case 38: delete keys_down['up'];    break;
      case 39: delete keys_down['right']; break;
      case 40: delete keys_down['down'];  break;
    }
  });
  
  window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          window.oRequestAnimationFrame      ||
          window.msRequestAnimationFrame     ||
          function( callback ){
            window.setTimeout(callback, 1000 / 60);
          };
  })();
  
  (function animloop(){
    requestAnimFrame(animloop);
    frame++;
    anim_subframe++;
    if (anim_subframe == 5) {
      anim_subframe = 0;
      anim_frame = (anim_frame + 1) % 4;
    }
    draw_scenery();
    draw_debug();
    draw_entities();
    update_entities();
    delete_entities();
    add_entities();
  })();

})

</script>
</body>

</html>

