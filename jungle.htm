<!-- 15x12 grid, each square 32x32 pixels -->

<html>

<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
</head>

<body>
<canvas id="canvas" width="640" height="480"></canvas>
<script type="text/javascript">

// The unchanging background of the world.
// 0: bare
// 1: grass
// 2: water
// 3: tree
var scenery =
  [ [ 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3 ]
  , [ 3, 3, 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 3, 3, 3 ]
  , [ 3, 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 3, 3 ]
  , [ 3, 3, 3, 3, 2, 2, 0, 0, 0, 0, 0, 3, 3, 3, 3 ]
  , [ 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3 ]
  , [ 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3 ]
  , [ 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3 ]
  , [ 3, 3, 3, 3, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3 ]
  , [ 3, 3, 3, 3, 3, 2, 2, 0, 0, 3, 3, 3, 0, 3, 3 ]
  , [ 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3 ]
  , [ 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3 ]
  , [ 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3 ]
  ];

var word = 'FIRST';
var letters = '';
var apples = 0;
var bridges = 0;

function newTile(letter, r, c) {
  return { sprite: 'tile'
         , x:      c * 32
         , y:      r * 32
         , letter: letter
         };
}

function newPlayer(r, c) {
  return { sprite: 'player'
         , x:      c * 32
         , y:      r * 32
         , facing: 'down'
         , state:  'stopped'
         };
}

function newDartDemon(r, c) {
  return { sprite: 'dartdemon'
         , x:      c * 32
         , y:      r * 32
         , facing: 'down'
         , state:  'stopped'
         };
}

// Entities are square-sized objects which can change state.
var floor_entities =
  [ newTile('F', 6, 10)
  , newTile('I', 6, 11)
  , newTile('R', 6, 12)
  , newTile('S', 7, 12)
  , newTile('T', 8, 12)
  ];
var body_entities =
  [ newPlayer(4, 7)
  , newDartDemon(3, 8)
  ];

function makeImage(src) {
  var img = new Image();
  img.src = src;
  return img;
}

images = {};

function imageURL(entity) {
  switch (entity.sprite) {
    case 'tile':
      return 'img/tile/' + entity.letter + '.png';
    case 'player':
      return 'img/player/' + entity.facing + '.png';
    case 'dartdemon':
      return 'img/dartdemon/' + entity.facing + '.png';
  }
}

function getImage(entity) {
  var url = imageURL(entity);
  if (typeof images[url] == 'undefined') {
    var img = makeImage(url);
    images[url] = img;
    return img;
  }
  return images[url];
}

var frame = 0;
var width = 640;
var height = 480;

var keys_down = {};

// indices of floor entities which will be deleted on end of frame
var to_delete = {};

// 'playing', 'dead', 'complete'
var status = 'playing';

$(document).ready(function(){

  var canvas = $('#canvas')[0];
  var ctx = canvas.getContext('2d');
  
  function draw_scenery() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width, height);
    
    var r, c;
    for (r = 0; r < scenery.length; r++) {
      for (c = 0; c < scenery[0].length; c++) {
        switch (scenery[r][c]) {
          case 0: ctx.fillStyle = '#ffffcc'; break;
          case 1: ctx.fillStyle = '#00ff00'; break;
          case 2: ctx.fillStyle = '#0033ff'; break;
          case 3: ctx.fillStyle = '#006600'; break;
        }
        ctx.fillRect(c * 32, r * 32, 32, 32);
      }
    }
  }
  
  function draw_debug() {
    ctx.fillStyle = 'white';
    var frameText = Math.floor(frame / 60) + ' | ' + (frame % 60);
    ctx.fillText(frameText, 10, 400);
    ctx.fillText('Letters: ' + letters, 10, 415);
    ctx.fillText('Target word: ' + word, 10, 430);
    if (status == 'dead') {
      ctx.fillText('Dead...', 10, 445);
    }
    else if (letters == word) {
      ctx.fillText('Victory!', 10, 445);
    }
    else if (word.indexOf(letters) === 0) {
      ctx.fillText('Playing', 10, 445);
    }
    else {
      ctx.fillText('Failure...', 10, 445);
    }
  }
  
  function draw_entities() {
    for (var i = 0; i < floor_entities.length; i++) {
      var entity = floor_entities[i];
      ctx.drawImage(getImage(entity), entity.x, entity.y);
    }
    for (var i = 0; i < body_entities.length; i++) {
      var entity = body_entities[i];
      ctx.drawImage(getImage(entity), entity.x, entity.y);
    }
  }
  
  // row and column should be multiples of 0.5.
  function is_occupied(row, column, index) {
    for (var i = 0; i < body_entities.length; i++) {
      if (i == index) continue;
      var entity = body_entities[i];
      var x = entity.x;
      var y = entity.y;
      var cx = column * 32;
      var ry = row * 32;
      if
        (  cx - 32 < x
        && x < cx + 32
        && ry - 32 < y
        && y < ry + 32
        ) {
        return true;
      }
    }
    return !walkable_bg(row, column);
  }
  
  // row and column should be multiples of 0.5.
  function walkable_bg(row, column) {
    if (row != Math.floor(row)) {
      return walkable_bg(row - 0.5, column) && walkable_bg(row + 0.5, column);
    }
    if (column != Math.floor(column)) {
      return walkable_bg(row, column - 0.5) && walkable_bg(row, column + 0.5);
    }
    if (scenery[row][column] == 2) return false;
    if (scenery[row][column] == 3) return false;
    return true;
  }
  
  // returns [r, c] or null, where r and c are multiples of 0.5.
  function get_square(entity) {
    var x = entity.x;
    var y = entity.y;
    if (x % 16 != 0 || y % 16 != 0) {
      return null;
    }
    return [y / 32, x / 32];
  }
  
  function get_next_square(entity, direction) {
    var sq = get_square(entity);
    var r = sq[0];
    var c = sq[1];
    switch (direction) {
      case 'left': return [r, c - 0.5];
      case 'right': return [r, c + 0.5];
      case 'up': return [r - 0.5, c];
      case 'down': return [r + 0.5, c];
    }
  }
  
  function bump(entity) {
    switch (entity.facing) {
      case 'left':  entity.x -= 2; break;
      case 'right': entity.x += 2; break;
      case 'up':    entity.y -= 2; break;
      case 'down':  entity.y += 2; break;
    }
  }
  
  function start_moving(entity, direction) {
    entity.facing = direction;
    entity.state = 'moving';
    bump(entity);
  }
  
  function kill() {
    for (var i = 0; i < body_entities.length; i++) {
      body_entities[i].state = 'frozen';
    }
    status = 'dead';
  }
  
  function check_pickup(x, y) {
    for (var i = 0; i < floor_entities.length; i++) {
      var entity = floor_entities[i];
      if (entity.x == x && entity.y == y) {
        to_delete[i] = true;
        switch (entity.sprite) {
          case 'tile':
            letters += entity.letter;
            if (letters == word) {
              status = 'complete';
            }
            break;
        }
      }
    }
  }
  
  // Handles updating the moving/stopped state, and applying movement to
  // position.
  function check_movement(entity, index) {
    if (entity.state == 'moving') {
      bump(entity);
      if (entity.x % 16 == 0 && entity.y % 16 == 0) {
        entity.state = 'stopped';
        if (entity.sprite == 'player') {
          check_pickup(entity.x, entity.y);
        }
      }
    }
    else if (entity.state == 'stopped') {
      if (entity.sprite == 'player') {
        var kd = Object.keys(keys_down);
        if (kd.length) {
          var dir = kd[0];
          entity.facing = dir;
          if (can_move(entity, dir, index)) {
            start_moving(entity, dir);
          }
        }
      }
    }
  }
  
  function can_move(entity, direction, index) {
    var next_sq = get_next_square(entity, direction);
    return !is_occupied(next_sq[0], next_sq[1], index);
  }
  
  function update_entities() {
    for (var i = 0; i < body_entities.length; i++) {
      var entity = body_entities[i];
      check_movement(entity, i);
    }
  }
  
  function delete_entities() {
    var indices = Object.keys(to_delete);
    indices.sort();
    for (var i = indices.length - 1; i >= 0; i--) {
      floor_entities.splice(indices[i], 1);
    }
    to_delete = {};
  }
  
  $(document).keydown(function(evt) {
    switch (evt.which) {
      case 37: keys_down['left']  = true; break;
      case 38: keys_down['up']    = true; break;
      case 39: keys_down['right'] = true; break;
      case 40: keys_down['down']  = true; break;
      case 75: kill(); break; // K
    }
  });
  
  $(document).keyup(function(evt) {
    switch (evt.which) {
      case 37: delete keys_down['left'];  break;
      case 38: delete keys_down['up'];    break;
      case 39: delete keys_down['right']; break;
      case 40: delete keys_down['down'];  break;
    }
  });
  
  window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          window.oRequestAnimationFrame      ||
          window.msRequestAnimationFrame     ||
          function( callback ){
            window.setTimeout(callback, 1000 / 60);
          };
  })();
  
  (function animloop(){
    requestAnimFrame(animloop);
    frame += 1;
    draw_scenery();
    draw_debug();
    draw_entities();
    update_entities();
    delete_entities();
  })();

})

</script>
</body>

</html>

